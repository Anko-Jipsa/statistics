cat("Estimated probability for rho:",rho[i], "=", estprob_4[i], "\n")
}
plot(rho, estprob_4, col="red",
main="P4", xlab="ρ", ylab="Probability")
#### QUESTION 4
# Arguments
mnData = read.csv("~/Downloads/mnData.txt", sep="")
mnData = data.matrix(mnData)
mle_est = function(data){
#' Run grid search MLE to find optimal parameters.
#'
#' @param data (array): Normally distributed sequences.
#' @return (vector): A vector contains optimal parameter values.
# Sample
y = data
# MLE for mu
# Likelihood function is maximized if mu is equal to the sample mean (e.g. mu = sum(x)/n)
mu = colMeans(y)
# Parameters setup
fixed_variance = rep(1,length(mu)) # Sigma^2 = 1
dim = length(fixed_variance)
corr = matrix(0, nrow=dim, ncol=dim)
k = length(mu)
n = nrow(y)
# MLE estimation for varying "ρ"
# Grid search method to find optimal "ρ" for constructing covariance matrix that maximises Log-likelihood
rho_list = seq(from=-0.99, to=0.99, by=0.01)
ll_list = rep(0, length(rho_list)) # LL values for each grid search
for (x in seq_along(rho_list)){
iter_rho = rho_list[x]
# Constructing covariance matrix
for (i in 1:dim) {
for (j in 1:dim) {
corr[i,j] = iter_rho^(abs(i-j))
}
}
cov_mat = sqrt(fixed_variance) %*% t(sqrt(fixed_variance)) * corr
LL_third_comp =  rep(0, n)
for (j in 1:n){
LL_third_comp[j] = t(y[j,]-mu) %*% ginv(cov_mat) %*% (y[j,]-mu)
}
ll_list[x] = -.5*n*k*log(2*pi) -.5*n*log(det(cov_mat)) - .5*sum(LL_third_comp)
print("Correlation value:")
print(iter_rho)
print("Log-likelihood")
print(ll_list[x])
cat("\n")
}
# Index of maximum log-likelihood value
mle_index = which.max(ll_list)
# Graphical illustration
plot(rho_list, ll_list, main="Grid search MLE",
type="l", xlab="ρ", ylab="Log-Likelihood")
abline(v=rho_list[mle_index], col="red", lwd=3, lty=2)
coeff_hat = c(array(mu), rho_list[mle_index])
names(coeff_hat) = c("μ1", "μ2", "μ3", "μ4", "μ5", "μ6", "μ7", "μ8", "ρ")
return(coeff_hat)
}
coeff_hat = mle_est(mnData)
coeff_hat
var(mnData)
print(coeff_hat)
print(mean(mnData))
print(colMeans(mnData))
print(cor(mnData))
print(cov(mnData))
print(cov(mnData)[1,1]/cov(mnData)[1,2])
print(cov(mnData)[1,1]/cov(mnData)[2,1])
print(cov(mnData)[2,1]/cov(mnData)[1,1])
print(cov(mnData)[3,1]/cov(mnData)[2,1])
#Exercise2 (1)
# my_function: generating n random vectors from a p-variate normal distribution
mv_rnorm <- function(cov_matrix, p, n, mu){
ll <- chol(solve(cov_matrix))
z <- matrix(rnorm(p*n), nrow = p)
t(solve(ll) %*% z + mu) # return sample_data that has n rows and p cols
}
#Exercise2 (2)
# my_function: calculating P1(rho)
P1_rho <- function(sample_data){
p <- dim(sample_data)[2] # ncol
n <- dim(sample_data)[1] # nrow
p1_true <- 0
for (i in 1:n){
if (all(sample_data[i,] > rep(-1,p)) & all(sample_data[i,] < rep(4,p)))
p1_true <- p1_true + 1
}
p1_true / n # return P1(rho)
}
# my_function: calculating P2(rho)
P2_rho <- function(sample_data){
p <- dim(sample_data)[2] # ncol
n <- dim(sample_data)[1] # nrow
p2_true <- 0
for (i in 1:n){
if(sum(abs(sample_data[i,])) <= 8)
p2_true <- p2_true + 1
}
p2_true / n # return P2(rho)
}
n <- 10000 # sample_data size
p <- 8 # p-variate
mu <- rep(c(-1,1), 4) # mean
sigma2 <- 1.5 # variance
# generating correlation and covariance matrix
rho <- seq(-0.95, 0.95, 0.01) # rho vector
p1 <- rep(0,length(rho)) # P1(rho) vector
p2 <- rep(0,length(rho)) # P2(rho) vector
for (t in 1:length(rho)){
rho_t <- rho[t]
corr_matrix <- matrix(rep(0,p^2), nrow = p, ncol = p) # initialization
cov_matrix <- matrix(rep(0,p^2), nrow = p, ncol = p) # initialization
for (j in 1:p){
for(i in 1:p){
corr_matrix[i,j] <- rho_t^(abs(j-i))
cov_matrix[i,j] <- corr_matrix[i,j] * sigma2
}
}
# generating n random vectors from a p-variate normal distribution
sample_data <- mv_rnorm(cov_matrix, p, n, mu)
p1[t] <- P1_rho(sample_data) # calculating P1(rho)
p2[t] <- P2_rho(sample_data) # calculating P2(rho)
}
# plotting
par(mfrow = c(2,1))
plot(rho, p1, xlab=expression(rho), ylab="P1")
plot(rho, p2, xlab=expression(rho), ylab="P2")
#Exercise2 (3)
# my_function: alculating P5(rho) = P(X1>0, X2>0, X3>0);
P5_rho <- function(sample_data){
p <- 3 # ncol = 3
n <- dim(sample_data)[1] # nrow
p5_true <- 0
for (i in 1:n){
if (all(sample_data[i,] > 0))
p5_true <- p5_true + 1
}
p5_true / n # return P5(rho)
}
# my_function: calculating P6(rho) = P(X2>0)
P6_rho <- function(sample_data){
p <- 3 # ncol = 3
n <- dim(sample_data)[1] # nrow
p6_true <- 0
for (i in 1:n){
if (sample_data[i, 2] > 0)
p6_true <- p6_true + 1
}
p6_true / n # return P6(rho)
}
# X1, X2, X3 follow continuous distribution
# so P(X1>0, X2=0, X3>0) = 0, P(X2=0) = 0
# then P(X1>0, X2<0, X3>0) = 1 - P(X1>0, X2>0, X3>0) = 1 - P5
# P(X2<0) = 1 - P(X2>0) = 1 - P6
# we can get P3 = P5 / P6, P4 = (1 - P5) / (1 - P6)
n <- 10000 # sample_data size
p <- 3 # p-variate
mu <- rep(0, 8) # mean
sigma2 <- 0.5 # variance
# generating correlation and covariance matrix
rho <- seq(-0.95, 0.95, 0.01) # rho vector
p3 <- rep(0,length(rho)) # P3(rho) vector
p4 <- rep(0,length(rho)) # P4(rho) vector
p5 <- rep(0,length(rho)) # P5(rho) vector
p6 <- rep(0,length(rho)) # P6(rho) vector
for (t in 1:length(rho)){
rho_t <- rho[t]
corr_matrix <- matrix(rep(0,p^2), nrow = p, ncol = p) # initialization
cov_matrix <- matrix(rep(0,p^2), nrow = p, ncol = p) # initialization
for (j in 1:p){
for(i in 1:p){
corr_matrix[i,j] <- rho_t^(abs(j-i))
cov_matrix[i,j] <- corr_matrix[i,j] * sigma2
}
}
# generating n random vectors from a p-variate normal distribution
sample_data <- mv_rnorm(cov_matrix, p, n, mu)
p5[t] <- P5_rho(sample_data) # calculating P5(rho)
p6[t] <- P6_rho(sample_data) # calculating P6(rho)
p3[t] <- p5[t] / p6[t]
p4[t] <- (1 - p5[t]) / (1 - p6[t])
}
# plotting
par(mfrow = c(2,1))
plot(rho, p3, xlab=expression(rho), ylab="P3")
plot(rho, p4, xlab=expression(rho), ylab="P4")
#Exercise2 (4)
sample_data <- data.matrix(read.table("Downloads/mnData.txt"))
p <- dim(sample_data)[2]
n <- dim(sample_data)[1]
mu_mle <- rep(0, p) #  mu_mle denotes ML estimates for mu
# calculating ML estimates for mu
for (j in 1:p){
mu_mle[j] <- mean(sample_data[,j])
}
rho <- seq(-0.95, 0.95, 0.01) # rho vector
sigma2 <- 1
lnL <- rep(0, length(rho)) # lnL stores value of log likelihood function given a certain rho
for (t in 1:length(rho)){
rho_t <- rho[t]
corr_matrix <- matrix(rep(0, p^2), nrow = p, ncol = p) # initialization
cov_matrix <- matrix(rep(0, p^2), nrow = p, ncol = p) # initialization
for (j in 1:p){
for(i in 1:p){
corr_matrix[i,j] <- rho_t^(abs(j-i))
cov_matrix[i,j] <- corr_matrix[i,j] * sigma2 # generate the cov_matrix given a certain rho
}
}
for (i in 1:n){
print(lnL[t])
lnL[t] <- lnL[t] - p/2 * log(2*pi) - 1/2 * log(det(cov_matrix)) - 1/2 * t(sample_data[i,] - mu_mle) %*% solve(cov_matrix) %*% (sample_data[i,] - mu_mle)
}
}
plot(rho, lnL, type="l", xlab=expression(rho), ylab="lnL")
m_lnL <- max(lnL)
rho_mle <- rho[lnL == m_lnL]  # we can get rho_mle = -0.59
#Exercise2 (1)
# my_function: generating n random vectors from a p-variate normal distribution
mv_rnorm <- function(cov_matrix, p, n, mu){
ll <- chol(solve(cov_matrix))
z <- matrix(rnorm(p*n), nrow = p)
t(solve(ll) %*% z + mu) # return sample_data that has n rows and p cols
}
#Exercise2 (2)
# my_function: calculating P1(rho)
P1_rho <- function(sample_data){
p <- dim(sample_data)[2] # ncol
n <- dim(sample_data)[1] # nrow
p1_true <- 0
for (i in 1:n){
if (all(sample_data[i,] > rep(-1,p)) & all(sample_data[i,] < rep(4,p)))
p1_true <- p1_true + 1
}
p1_true / n # return P1(rho)
}
# my_function: calculating P2(rho)
P2_rho <- function(sample_data){
p <- dim(sample_data)[2] # ncol
n <- dim(sample_data)[1] # nrow
p2_true <- 0
for (i in 1:n){
if(sum(abs(sample_data[i,])) <= 8)
p2_true <- p2_true + 1
}
p2_true / n # return P2(rho)
}
n <- 10000 # sample_data size
p <- 8 # p-variate
mu <- rep(c(-1,1), 4) # mean
sigma2 <- 1.5 # variance
# generating correlation and covariance matrix
rho <- seq(-0.95, 0.95, 0.01) # rho vector
p1 <- rep(0,length(rho)) # P1(rho) vector
p2 <- rep(0,length(rho)) # P2(rho) vector
for (t in 1:length(rho)){
rho_t <- rho[t]
corr_matrix <- matrix(rep(0,p^2), nrow = p, ncol = p) # initialization
cov_matrix <- matrix(rep(0,p^2), nrow = p, ncol = p) # initialization
for (j in 1:p){
for(i in 1:p){
corr_matrix[i,j] <- rho_t^(abs(j-i))
cov_matrix[i,j] <- corr_matrix[i,j] * sigma2
}
}
# generating n random vectors from a p-variate normal distribution
sample_data <- mv_rnorm(cov_matrix, p, n, mu)
p1[t] <- P1_rho(sample_data) # calculating P1(rho)
p2[t] <- P2_rho(sample_data) # calculating P2(rho)
}
# plotting
par(mfrow = c(2,1))
plot(rho, p1, xlab=expression(rho), ylab="P1")
plot(rho, p2, xlab=expression(rho), ylab="P2")
#Exercise2 (3)
# my_function: alculating P5(rho) = P(X1>0, X2>0, X3>0);
P5_rho <- function(sample_data){
p <- 3 # ncol = 3
n <- dim(sample_data)[1] # nrow
p5_true <- 0
for (i in 1:n){
if (all(sample_data[i,] > 0))
p5_true <- p5_true + 1
}
p5_true / n # return P5(rho)
}
# my_function: calculating P6(rho) = P(X2>0)
P6_rho <- function(sample_data){
p <- 3 # ncol = 3
n <- dim(sample_data)[1] # nrow
p6_true <- 0
for (i in 1:n){
if (sample_data[i, 2] > 0)
p6_true <- p6_true + 1
}
p6_true / n # return P6(rho)
}
# X1, X2, X3 follow continuous distribution
# so P(X1>0, X2=0, X3>0) = 0, P(X2=0) = 0
# then P(X1>0, X2<0, X3>0) = 1 - P(X1>0, X2>0, X3>0) = 1 - P5
# P(X2<0) = 1 - P(X2>0) = 1 - P6
# we can get P3 = P5 / P6, P4 = (1 - P5) / (1 - P6)
n <- 10000 # sample_data size
p <- 3 # p-variate
mu <- rep(0, 8) # mean
sigma2 <- 0.5 # variance
# generating correlation and covariance matrix
rho <- seq(-0.95, 0.95, 0.01) # rho vector
p3 <- rep(0,length(rho)) # P3(rho) vector
p4 <- rep(0,length(rho)) # P4(rho) vector
p5 <- rep(0,length(rho)) # P5(rho) vector
p6 <- rep(0,length(rho)) # P6(rho) vector
for (t in 1:length(rho)){
rho_t <- rho[t]
corr_matrix <- matrix(rep(0,p^2), nrow = p, ncol = p) # initialization
cov_matrix <- matrix(rep(0,p^2), nrow = p, ncol = p) # initialization
for (j in 1:p){
for(i in 1:p){
corr_matrix[i,j] <- rho_t^(abs(j-i))
cov_matrix[i,j] <- corr_matrix[i,j] * sigma2
}
}
# generating n random vectors from a p-variate normal distribution
sample_data <- mv_rnorm(cov_matrix, p, n, mu)
p5[t] <- P5_rho(sample_data) # calculating P5(rho)
p6[t] <- P6_rho(sample_data) # calculating P6(rho)
p3[t] <- p5[t] / p6[t]
p4[t] <- (1 - p5[t]) / (1 - p6[t])
}
# plotting
par(mfrow = c(2,1))
plot(rho, p3, xlab=expression(rho), ylab="P3")
plot(rho, p4, xlab=expression(rho), ylab="P4")
#Exercise2 (4)
sample_data <- data.matrix(read.table("Downloads/mnData.txt"))
p <- dim(sample_data)[2]
n <- dim(sample_data)[1]
mu_mle <- rep(0, p) #  mu_mle denotes ML estimates for mu
# calculating ML estimates for mu
for (j in 1:p){
mu_mle[j] <- mean(sample_data[,j])
}
rho <- seq(-0.95, 0.95, 0.01) # rho vector
sigma2 <- 1
lnL <- rep(0, length(rho)) # lnL stores value of log likelihood function given a certain rho
for (t in 1:length(rho)){
rho_t <- rho[t]
corr_matrix <- matrix(rep(0, p^2), nrow = p, ncol = p) # initialization
cov_matrix <- matrix(rep(0, p^2), nrow = p, ncol = p) # initialization
for (j in 1:p){
for(i in 1:p){
corr_matrix[i,j] <- rho_t^(abs(j-i))
cov_matrix[i,j] <- corr_matrix[i,j] * sigma2 # generate the cov_matrix given a certain rho
}
}
for (i in 1:n){
lnL[t] <- lnL[t] - p/2 * log(2*pi) - 1/2 * log(det(cov_matrix)) - 1/2 * t(sample_data[i,] - mu_mle) %*% solve(cov_matrix) %*% (sample_data[i,] - mu_mle)
}
}
plot(rho, lnL, type="l", xlab=expression(rho), ylab="lnL")
m_lnL <- max(lnL)
rho_mle <- rho[lnL == m_lnL]  # we can get rho_mle = -0.59
rho_mle
#Exercise2 (1)
# my_function: generating n random vectors from a p-variate normal distribution
mv_rnorm <- function(cov_matrix, p, n, mu){
ll <- chol(solve(cov_matrix))
z <- matrix(rnorm(p*n), nrow = p)
t(solve(ll) %*% z + mu) # return sample_data that has n rows and p cols
}
#Exercise2 (2)
# my_function: calculating P1(rho)
P1_rho <- function(sample_data){
p <- dim(sample_data)[2] # ncol
n <- dim(sample_data)[1] # nrow
p1_true <- 0
for (i in 1:n){
if (all(sample_data[i,] > rep(-1,p)) & all(sample_data[i,] < rep(4,p)))
p1_true <- p1_true + 1
}
p1_true / n # return P1(rho)
}
# my_function: calculating P2(rho)
P2_rho <- function(sample_data){
p <- dim(sample_data)[2] # ncol
n <- dim(sample_data)[1] # nrow
p2_true <- 0
for (i in 1:n){
if(sum(abs(sample_data[i,])) <= 8)
p2_true <- p2_true + 1
}
p2_true / n # return P2(rho)
}
n <- 10000 # sample_data size
p <- 8 # p-variate
mu <- rep(c(-1,1), 4) # mean
sigma2 <- 1.5 # variance
# generating correlation and covariance matrix
rho <- seq(-0.95, 0.95, 0.01) # rho vector
p1 <- rep(0,length(rho)) # P1(rho) vector
p2 <- rep(0,length(rho)) # P2(rho) vector
for (t in 1:length(rho)){
rho_t <- rho[t]
corr_matrix <- matrix(rep(0,p^2), nrow = p, ncol = p) # initialization
cov_matrix <- matrix(rep(0,p^2), nrow = p, ncol = p) # initialization
for (j in 1:p){
for(i in 1:p){
corr_matrix[i,j] <- rho_t^(abs(j-i))
cov_matrix[i,j] <- corr_matrix[i,j] * sigma2
}
}
# generating n random vectors from a p-variate normal distribution
sample_data <- mv_rnorm(cov_matrix, p, n, mu)
p1[t] <- P1_rho(sample_data) # calculating P1(rho)
p2[t] <- P2_rho(sample_data) # calculating P2(rho)
}
# plotting
par(mfrow = c(2,1))
plot(rho, p1, xlab=expression(rho), ylab="P1")
plot(rho, p2, xlab=expression(rho), ylab="P2")
#Exercise2 (3)
# my_function: alculating P5(rho) = P(X1>0, X2>0, X3>0);
P5_rho <- function(sample_data){
p <- 3 # ncol = 3
n <- dim(sample_data)[1] # nrow
p5_true <- 0
for (i in 1:n){
if (all(sample_data[i,] > 0))
p5_true <- p5_true + 1
}
p5_true / n # return P5(rho)
}
# my_function: calculating P6(rho) = P(X2>0)
P6_rho <- function(sample_data){
p <- 3 # ncol = 3
n <- dim(sample_data)[1] # nrow
p6_true <- 0
for (i in 1:n){
if (sample_data[i, 2] > 0)
p6_true <- p6_true + 1
}
p6_true / n # return P6(rho)
}
# X1, X2, X3 follow continuous distribution
# so P(X1>0, X2=0, X3>0) = 0, P(X2=0) = 0
# then P(X1>0, X2<0, X3>0) = 1 - P(X1>0, X2>0, X3>0) = 1 - P5
# P(X2<0) = 1 - P(X2>0) = 1 - P6
# we can get P3 = P5 / P6, P4 = (1 - P5) / (1 - P6)
n <- 10000 # sample_data size
p <- 3 # p-variate
mu <- rep(0, 8) # mean
sigma2 <- 0.5 # variance
# generating correlation and covariance matrix
rho <- seq(-0.95, 0.95, 0.01) # rho vector
p3 <- rep(0,length(rho)) # P3(rho) vector
p4 <- rep(0,length(rho)) # P4(rho) vector
p5 <- rep(0,length(rho)) # P5(rho) vector
p6 <- rep(0,length(rho)) # P6(rho) vector
for (t in 1:length(rho)){
rho_t <- rho[t]
corr_matrix <- matrix(rep(0,p^2), nrow = p, ncol = p) # initialization
cov_matrix <- matrix(rep(0,p^2), nrow = p, ncol = p) # initialization
for (j in 1:p){
for(i in 1:p){
corr_matrix[i,j] <- rho_t^(abs(j-i))
cov_matrix[i,j] <- corr_matrix[i,j] * sigma2
}
}
# generating n random vectors from a p-variate normal distribution
sample_data <- mv_rnorm(cov_matrix, p, n, mu)
p5[t] <- P5_rho(sample_data) # calculating P5(rho)
p6[t] <- P6_rho(sample_data) # calculating P6(rho)
p3[t] <- p5[t] / p6[t]
p4[t] <- (1 - p5[t]) / (1 - p6[t])
}
# plotting
par(mfrow = c(2,1))
plot(rho, p3, xlab=expression(rho), ylab="P3")
plot(rho, p4, xlab=expression(rho), ylab="P4")
#Exercise2 (4)
sample_data <- data.matrix(read.table("mnData.txt"))
p <- dim(sample_data)[2]
n <- dim(sample_data)[1]
mu_mle <- rep(0, p) #  mu_mle denotes ML estimates for mu
# calculating ML estimates for mu
for (j in 1:p){
mu_mle[j] <- mean(sample_data[,j])
}
rho <- seq(-0.95, 0.95, 0.01) # rho vector
sigma2 <- 1
lnL <- rep(0, length(rho)) # lnL stores value of log likelihood function given a certain rho
for (t in 1:length(rho)){
rho_t <- rho[t]
corr_matrix <- matrix(rep(0, p^2), nrow = p, ncol = p) # initialization
cov_matrix <- matrix(rep(0, p^2), nrow = p, ncol = p) # initialization
for (j in 1:p){
for(i in 1:p){
corr_matrix[i,j] <- rho_t^(abs(j-i))
cov_matrix[i,j] <- corr_matrix[i,j] * sigma2 # generate the cov_matrix given a certain rho
}
}
for (i in 1:n){
lnL[t] <- lnL[t] - p/2 * log(2*pi) - 1/2 * log(det(cov_matrix)) - 1/2 * t(sample_data[i,] - mu_mle) %*% solve(cov_matrix) %*% (sample_data[i,] - mu_mle)
}
}
plot(rho, lnL, type="l", xlab=expression(rho), ylab="lnL")
m_lnL <- max(lnL)
rho_mle <- rho[lnL == m_lnL]  # we can get rho_mle = -0.59
rho_mle
m_lnL
lnL
rho
rho_mle
